From: Robie Basak <robie.basak@canonical.com>
Date: Wed, 28 Sep 2011 14:45:30 +0100
Subject: [PATCH] Move console.log to a ringbuffer

Prevent a DoS by storing console output in a ringbuffer on the host,
instead of allowing it to grow indefinitely. Fixes bug 832507.

Updated 2012-03-12:

The following upstream commit refactored the get_console_output a bunch:
https://github.com/openstack/nova/commit/9b8275659b5de8c8291d64d48a11edd83a276837

Original patch has been modified to accommodate these changes.
(adam_g)


Origin: https://review.openstack.org/#change,706
Bug: https://code.launchpad.net/bugs/832507
Last-Update: 2012-03-12
Index: nova/Authors
===================================================================
--- nova.orig/Authors	2012-03-12 11:35:08.389976233 -0700
+++ nova/Authors	2012-03-12 11:38:34.085985121 -0700
@@ -156,6 +156,7 @@
 Rick Harris <rconradharris@gmail.com>
 Rob Kost <kost@isi.edu>
 Robert Esker <esker@netapp.com>
+Robie Basak <robie.basak@canonical.com>
 Russell Bryant <rbryant@redhat.com>
 Russell Sim <russell.sim@gmail.com>
 Ryan Lane <rlane@wikimedia.org>
Index: nova/nova/tests/test_libvirt.py
===================================================================
--- nova.orig/nova/tests/test_libvirt.py	2012-03-12 11:35:08.393976233 -0700
+++ nova/nova/tests/test_libvirt.py	2012-03-12 12:01:01.166043323 -0700
@@ -903,6 +903,8 @@
             (lambda t: t.findall(parameter)[1].get('name'), 'DHCPSERVER'),
             (lambda t: _ipv4_like(t.findall(parameter)[1].get('value'),
                                   '192.168.*.1'), True),
+            (lambda t: t.find('./devices/serial/source').get(
+                'path').split('/')[1], 'console.fifo'),
             (lambda t: t.find('./memory').text, '2097152')]
         if rescue:
             common_checks += [
@@ -2328,3 +2330,53 @@
 
         ref = self.libvirtconnection.finish_revert_migration(ins_ref, None)
         self.assertTrue(isinstance(ref, eventlet.event.Event))
+
+class ConsoleLoggerTestCase(test.TestCase):
+    def setUp(self):
+        super(ConsoleLoggerTestCase, self).setUp()
+        eventlet.monkey_patch()
+        self.directory_path = tempfile.mkdtemp()
+        self.ringbuffer_path = os.path.join(self.directory_path, 'ring')
+        self.fifo_path = os.path.join(self.directory_path, 'fifo')
+        os.mkfifo(self.fifo_path)
+        self.console_logger = connection.ConsoleLogger(self.fifo_path,
+                                                       self.ringbuffer_path)
+        eventlet.sleep(0)
+
+    def testWriteBytes(self, reopen_writer=False, reopen_reader=False):
+        fd = os.open(self.fifo_path, os.O_WRONLY)
+        os.write(fd, '0')
+        eventlet.sleep(0)
+        eventlet.sleep(0)
+        self.assertEquals(self.console_logger.ringbuffer.peek(), '0')
+        if reopen_writer:
+            os.close(fd)
+            fd = os.open(self.fifo_path, os.O_WRONLY)
+        if reopen_reader:
+            self.console_logger.close()
+            self.console_logger = connection.ConsoleLogger(
+                    self.fifo_path,
+                    self.ringbuffer_path)
+            eventlet.sleep(0)
+        os.write(fd, '1')
+        eventlet.sleep(0)
+        eventlet.sleep(0)
+        self.assertEquals(self.console_logger.ringbuffer.peek(), '01')
+        os.close(fd)
+
+    def testReopenWriter(self):
+        self.testWriteBytes(reopen_writer=True)
+
+    def testReopenReader(self):
+        self.testWriteBytes(reopen_reader=True)
+
+    def testReopenBoth(self):
+        self.testWriteBytes(reopen_writer=True, reopen_reader=True)
+
+    def tearDown(self):
+        super(ConsoleLoggerTestCase, self).tearDown()
+        if self.console_logger:
+            self.console_logger.close()
+        os.unlink(self.ringbuffer_path)
+        os.unlink(self.fifo_path)
+        os.rmdir(self.directory_path)
Index: nova/nova/tests/test_utils.py
===================================================================
--- nova.orig/nova/tests/test_utils.py	2012-03-12 11:35:08.393976233 -0700
+++ nova/nova/tests/test_utils.py	2012-03-12 12:03:42.722050303 -0700
@@ -17,6 +17,7 @@
 import __builtin__
 import datetime
 import hashlib
+import itertools
 import os
 import os.path
 import socket
@@ -26,6 +27,7 @@
 
 import iso8601
 import mox
+import nose
 
 import nova
 from nova import exception
@@ -831,6 +833,57 @@
         normed = utils.normalize_time(west)
         self._instaneous(normed, 2012, 2, 13, 23, 53, 07, 0)
 
+class RingBufferTestCase(test.TestCase):
+    """Unit test for utils.RingBuffer()."""
+    def setUp(self):
+        super(ingBufferTestCase, self).setUp()
+        self.f = tempfile.NamedTemporaryFile()
+        self.r = utils.RingBuffer(self.f.name, max_size=4)
+
+    def tearDown(self):
+        super(RingBufferTestCase, self).tearDown()
+        self.r.close()
+        self.f.close()
+
+    def testEmpty(self):
+        self.assertEquals(self.r.peek(), '')
+
+    def testReOpen(self):
+        self.r.write('1')
+        self.r.close()
+        self.r = utils.RingBuffer(self.f.name, max_size=4)
+        self.assertEquals(self.r.peek(), '1')
+
+
+def testPermutations():
+    """Test various permutations of writing to a RingBuffer.
+
+    Try all permutations of writing [0,5) bytes three times to a RingBuffer
+    of size 4. This makes use of nose's test generator capability so cannot
+    be a subclass of test.TestCase.
+
+    """
+    def check_buffer(r, expected):
+        nose.tools.eq_(r.peek(), expected)
+
+    SIZE = 4
+    for sequence in itertools.product(range(5), range(5), range(5)):
+        f = tempfile.NamedTemporaryFile()
+        r = utils.RingBuffer(f.name, max_size=SIZE)
+        source = itertools.count()
+        expected = ''
+
+        def next_n(n):
+            return ''.join(str(next(source)) for x in range(n))
+        for entry in sequence:
+            to_insert = next_n(entry)
+            expected += to_insert
+            expected = expected[max(0, len(expected) - SIZE):]
+            r.write(to_insert)
+            yield check_buffer, r, expected
+        r.close()
+        f.close()
+
 
 class TestLockCleanup(test.TestCase):
     """unit tests for utils.cleanup_file_locks()"""
Index: nova/nova/utils.py
===================================================================
--- nova.orig/nova/utils.py	2012-03-12 11:35:08.393976233 -0700
+++ nova/nova/utils.py	2012-03-12 12:04:27.134052222 -0700
@@ -33,6 +33,7 @@
 import shlex
 import shutil
 import socket
+import stat
 import struct
 import sys
 import tempfile
@@ -56,6 +57,7 @@
 from nova.openstack.common import cfg
 
 
+BITS_PER_BYTE = 8
 LOG = logging.getLogger(__name__)
 ISO_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"
 PERFECT_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%f"
@@ -1582,6 +1584,135 @@
     except exception.ProcessExecutionError:
         raise exception.FileNotFound(file_path=file_path)
 
+class RingBuffer(object):
+    """Generic userspace on-disk ringbuffer implementation."""
+    _header_max_int = (2 ** (struct.calcsize('I') * BITS_PER_BYTE)) - 1
+    _header_format = 'II'
+    _header_size = struct.calcsize(_header_format)
+
+    def __init__(self, backing_file, max_size=65536):
+        # We need one extra byte as the buffer is kept with
+        # one byte free to avoid the head==tail full/empty
+        # problem
+        max_size += 1
+
+        if not 0 < max_size <= RingBuffer._header_max_int:
+            raise ValueError(_('RingBuffer size out of range'))
+        had_already_existed = os.path.exists(backing_file)
+        self.f = self._open(backing_file)
+        if had_already_existed:
+            file_size = os.fstat(self.f.fileno()).st_size
+            if file_size:
+                current_size = file_size - self._header_size
+                if not 0 < current_size <= RingBuffer._header_max_int:
+                    self.f.close()
+                    raise ValueError(_('Disk RingBuffer size out of range'))
+                self.max_size = current_size
+
+                # If the file doesn't contain a header, assume it is corrupt
+                # and recreate
+                if file_size < self._header_size:
+                    self._write_header(0, 0)  # initialise to empty
+
+                # If head or tail point beyond the file then bomb out
+                head, tail = self._read_header()
+                if head >= current_size or tail >= current_size:
+                    self.f.close()
+                    raise ValueError(_('RingBuffer %s is corrupt') %
+                                     backing_file)
+            else:
+                # File is zero bytes: treat as new file
+                self.max_size = max_size
+                self._initialise_empty_file()
+        else:
+            self.max_size = max_size
+            self._initialise_empty_file()
+
+    def _initialise_empty_file(self):
+        os.ftruncate(self.f.fileno(), self.max_size + self._header_size)
+        self._write_header(0, 0)  # head == tail means no data
+
+    @staticmethod
+    def _open(filename):
+        """Open a file without truncating it for both reading and writing in
+        binary mode."""
+        # Built-in open() cannot open in read/write mode without truncating.
+        fd = os.open(filename, os.O_RDWR | os.O_CREAT, 0666)
+        return os.fdopen(fd, 'w+')
+
+    def _read_header(self):
+        self.f.seek(0)
+        return struct.unpack(self._header_format,
+                             self.f.read(self._header_size))
+
+    def _write_header(self, head, tail):
+        self.f.seek(0)
+        self.f.write(struct.pack(self._header_format, head, tail))
+
+    def _seek(self, pos):
+        """Seek to pos in data (ignoring header)."""
+        self.f.seek(self._header_size + pos)
+
+    def _read_slice(self, start, end):
+        if start == end:
+            return ''
+
+        self._seek(start)
+        return self.f.read(end - start)
+
+    def _write_slice(self, pos, data):
+        self._seek(pos)
+        self.f.write(data)
+
+    def peek(self):
+        """Read the entire ringbuffer without consuming it."""
+        head, tail = self._read_header()
+        if head < tail:
+            # Wraps around
+            before_wrap = self._read_slice(tail, self.max_size)
+            after_wrap = self._read_slice(0, head)
+            return before_wrap + after_wrap
+        else:
+            # Just from here to head
+            return self._read_slice(tail, head)
+
+    def write(self, data):
+        """Write some amount of data to the ringbuffer, discarding the oldest
+        data as max_size is exceeded."""
+        head, tail = self._read_header()
+        while data:
+            # Amount of data to be written on this pass
+            len_to_write = min(len(data), self.max_size - head)
+
+            # Where head will be after this write
+            new_head = head + len_to_write
+
+            # In the next comparison, new_head may be self.max_size which is
+            # logically the same point as tail == 0 and must still be within
+            # the range tested.
+            unwrapped_tail = tail if tail else self.max_size
+
+            if head < unwrapped_tail <= new_head:
+                # Write will go past tail so tail needs to be pushed back
+                tail = new_head + 1  # one past head to indicate full
+                tail %= self.max_size
+                self._write_header(head, tail)
+
+            # Write the data
+            self._write_slice(head, data[:len_to_write])
+            data = data[len_to_write:]  # data now left
+
+            # Push head back
+            head = new_head
+            head %= self.max_size
+            self._write_header(head, tail)
+
+    def flush(self):
+        self.f.flush()
+
+    def close(self):
+        self.f.close()
+
 
 @contextlib.contextmanager
 def temporary_chown(path, owner_uid=None):
Index: nova/nova/virt/libvirt/connection.py
===================================================================
--- nova.orig/nova/virt/libvirt/connection.py	2012-03-12 11:35:08.393976233 -0700
+++ nova/nova/virt/libvirt/connection.py	2012-03-12 12:03:28.338049682 -0700
@@ -39,15 +39,19 @@
 
 """
 
+import errno
 import hashlib
 import functools
 import glob
 import multiprocessing
 import os
+import select
 import shutil
+import stat
 import sys
 import uuid
 
+import eventlet
 from eventlet import greenthread
 from xml.dom import minidom
 from xml.etree import ElementTree
@@ -148,6 +152,9 @@
                help='Override the default disk prefix for the devices attached'
                     ' to a server, which is dependent on libvirt_type. '
                     '(valid options are: sd, xvd, uvd, vd)'),
+    cfg.IntOpt('libvirt_console_log_size',
+               default=65536,
+               help='libvirt console log ringbugger size'),
     cfg.IntOpt('libvirt_wait_soft_reboot_seconds',
                default=120,
                help='Number of seconds to wait for instance to shut down after'
@@ -186,6 +193,57 @@
     return 'disk.eph' + str(ephemeral['num'])
 
 
+class ConsoleLogger(object):
+
+    def __init__(self, fifo_path, ringbuffer_path):
+        self.fifo_path = fifo_path
+        self.fd = None
+        self.data_queue = eventlet.queue.LightQueue(0)
+        self.ringbuffer = utils.RingBuffer(ringbuffer_path,
+                                           FLAGS.libvirt_console_log_size)
+        self.reader_thread = eventlet.spawn(self._reader_thread_func)
+        self.writer_thread = eventlet.spawn(self._writer_thread_func)
+
+    def _reopen(self):
+        if self.fd is not None:
+            os.close(self.fd)
+            self.fd = None
+        self.fd = os.open(self.fifo_path, os.O_RDONLY | os.O_NONBLOCK)
+
+    def _reader_thread_func(self):
+        self._reopen()
+        while True:
+            select.select([self.fd], [], [])
+            data = os.read(self.fd, 1024)
+            if data:
+                self.data_queue.put(data)
+            else:
+                self._reopen()
+
+    def _writer_thread_func(self):
+        try:
+            data = self.data_queue.get()
+            while data:
+                self.ringbuffer.write(data)
+                data = self.data_queue.get()
+        finally:
+            self.ringbuffer.close()
+
+    def close(self):
+        self.reader_thread.kill()
+        self.data_queue.put(None)
+        try:
+            self.writer_thread.wait()
+        except eventlet.greenlet.GreenletExit:
+            pass
+        if self.fd is not None:
+            os.close(self.fd)
+            self.fd = None
+
+    def peek(self):
+        return self.ringbuffer.peek()
+
+
 class LibvirtConnection(driver.ComputeDriver):
 
     def __init__(self, read_only):
@@ -219,6 +277,8 @@
 
         self.image_cache_manager = imagecache.ImageCacheManager()
 
+        self.console_loggers = dict()
+
     @property
     def host_state(self):
         if not self._host_state:
@@ -227,7 +287,11 @@
 
     def init_host(self, host):
         # NOTE(nsokolov): moved instance restarting to ComputeManager
-        pass
+        for name in self.list_instances():
+            base_path = os.path.join(FLAGS.instances_path, name)
+            fifo_path = os.path.join(base_path, 'console.fifo.out')
+            ringbuffer_path = os.path.join(base_path, 'console.ring')
+            self._start_console_logger(name, fifo_path, ringbuffer_path)
 
     @property
     def libvirt_xml(self):
@@ -305,6 +369,15 @@
                 for x in self._conn.listDomainsID()
                 if x != 0]  # We skip domains with ID 0 (hypervisors).
 
+    def _start_console_logger(self, name, fifo_path, ringbuffer_path):
+        self._stop_console_logger(name)
+        self.console_loggers[name] = ConsoleLogger(fifo_path, ringbuffer_path)
+
+    def _stop_console_logger(self, name):
+        if name in self.console_loggers:
+            self.console_loggers[name].close()
+            del self.console_loggers[name]
+
     @staticmethod
     def _map_to_instance_info(domain):
         """Gets info from a virsh domain object into an InstanceInfo"""
@@ -430,6 +503,7 @@
         target = os.path.join(FLAGS.instances_path, instance['name'])
         LOG.info(_('Deleting instance files %(target)s') % locals(),
                  instance=instance)
+        self._stop_console_logger(instance['name'])
         if FLAGS.libvirt_type == 'lxc':
             disk.destroy_container(self.container)
         if os.path.exists(target):
@@ -907,6 +981,14 @@
         xml = virt_dom.XMLDesc(0)
         tree = ElementTree.fromstring(xml)
 
+        # Prefer a fifo console to everything else.  Patched here by Ubuntu.
+        node = tree.find("./devices/console[@type='pipe']/source")
+        if node is not None:
+            console_fifo = os.path.join(FLAGS.instances_path, instance['name'],
+                                        'console.fifo.out')
+            libvirt_utils.chown(console_fifo, os.getuid())
+            return self.console_loggers[instance['name']].peek()
+
         # If the guest has a console logging to a file prefer to use that
         node = tree.find("./devices/console[@type='file']/source")
         if node is not None:
@@ -920,13 +1002,12 @@
 
         pty = node.get("path")
 
-        console_log = os.path.join(FLAGS.instances_path, instance['name'],
-                                   'console.log')
-        libvirt_utils.chown(console_log, os.getuid())
+        console_fifo = os.path.join(FLAGS.instances_path, instance['name'],
+                                   'console.fifo.out')
+        libvirt_utils.chown(console_fifo, os.getuid())
         data = self._flush_libvirt_console(pty)
-        fpath = self._append_to_file(data, console_log)
-
-        return libvirt_utils.load_file(fpath)
+        fpath = self._append_to_file(data, console_fifo)
+        return self.console_loggers[instance['name']].peek()
 
     @staticmethod
     def get_host_ip_addr():
@@ -1052,8 +1133,25 @@
             container_dir = '%s/rootfs' % basepath(suffix='')
             libvirt_utils.ensure_tree(container_dir)
 
-        # NOTE(vish): No need add the suffix to console.log
-        libvirt_utils.write_to_file(basepath('console.log', ''), '', 007)
+        # NOTE(vish): No need add the suffix
+        console_fifo = basepath('console.fifo', '')
+        console_ring = basepath('console.ring', '')
+
+        for fifo_suffix in ['.in', '.out']:
+            console_fifo_suffix = console_fifo + fifo_suffix
+            try:
+                console_fifo_stat = os.stat(console_fifo_suffix)
+            except OSError, e:
+                if e.errno == errno.ENOENT:
+                    os.mkfifo(console_fifo_suffix, 0660)
+                else:
+                    raise
+            else:
+                utils.execute('chown', os.getuid(), console_fifo,
+                              run_as_root=True)
+        self._start_console_logger(instance['name'],
+                                   console_fifo + '.out',
+                                   console_ring)
 
         if not disk_images:
             disk_images = {'image_id': instance['image_ref'],
Index: nova/nova/virt/libvirt.xml.template
===================================================================
--- nova.orig/nova/virt/libvirt.xml.template	2012-03-12 11:35:08.393976233 -0700
+++ nova/nova/virt/libvirt.xml.template	2012-03-12 11:40:39.213990527 -0700
@@ -168,8 +168,8 @@
 	     client app is connected. Thus we can't get away
 	     with a single type=pty console. Instead we have
 	     to configure two separate consoles. -->
-        <serial type='file'>
-            <source path='${basepath}/console.log'/>
+        <serial type='pipe'>
+            <source path='${basepath}/console.fifo'/>
         </serial>
         <serial type='pty'/>
 #else
