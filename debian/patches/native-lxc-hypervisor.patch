Description: This patch adds native lxc support to Nova.
Author Chuck Short <zulcss@ubuntu.com>
Forwarded: No
diff --git a/etc/nova/rootwrap.d/compute.filters b/etc/nova/rootwrap.d/compute.filters
index e98c3f2..e6b7117 100644
--- a/etc/nova/rootwrap.d/compute.filters
+++ b/etc/nova/rootwrap.d/compute.filters
@@ -209,3 +209,10 @@ rpc.mountd: CommandFilter, rpc.mountd, root
 
 # nova/virt/libvirt/utils.py:
 rbd: CommandFilter, rbd, root
+
+# nova/virt/vmutils.py
+lxc-info: CommandFilter, lxc-info, root
+lxc-ls: CommandFilter, lxc-ls, root
+lxc-start: CommandFilter, lxc-start, root
+lxc-stop: CommandFilter, lxc-stop, root
+lxc-destroy CommandFilter, lxc-destroy, root
diff --git a/nova/virt/lxc/__init__.py b/nova/virt/lxc/__init__.py
new file mode 100644
index 0000000..4cbe183
--- /dev/null
+++ b/nova/virt/lxc/__init__.py
@@ -0,0 +1,22 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright 2010 United States Government as represented by the
+# Administrator of the National Aeronautics and Space Administration.
+# All Rights Reserved.
+# Copyright (c) 2013 Canonical Ltd
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+from nova.virt.lxc import driver
+
+LXCDriver = driver.LXCDriver
diff --git a/nova/virt/lxc/config.tmpl b/nova/virt/lxc/config.tmpl
new file mode 100644
index 0000000..7e4478e
--- /dev/null
+++ b/nova/virt/lxc/config.tmpl
@@ -0,0 +1,52 @@
+# Template used to create this container: /usr/share/lxc/templates/lxc-ubuntu
+# Parameters passed to the template:
+lxc.network.type = veth
+lxc.network.hwaddr = {{ container_hwaddr }}
+lxc.network.flags = up
+lxc.network.link = {{ container_link }}
+lxc.rootfs = {{ container_rootfs }}
+lxc.mount = {{ container_fstab }}
+lxc.pivotdir = lxc_putold
+
+lxc.devttydir = lxc
+lxc.tty = 4
+lxc.pts = 1024
+
+lxc.utsname = {{ container_name }}
+lxc.cap.drop = sys_module mac_admin mac_override sys_time
+lxc.console = {{ console_file }}
+
+# When using LXC with apparmor, uncomment the next line to run unconfined:
+lxc.aa_profile = unconfined
+
+# To support container nesting on an Ubuntu host, uncomment next two lines:
+#lxc.aa_profile = lxc-container-default-with-nesting
+#lxc.hook.mount = /usr/share/lxc/hooks/mountcgroups
+
+lxc.cgroup.devices.deny = a
+# Allow any mknod (but not using the node)
+lxc.cgroup.devices.allow = c *:* m
+lxc.cgroup.devices.allow = b *:* m
+# /dev/null and zero
+lxc.cgroup.devices.allow = c 1:3 rwm
+lxc.cgroup.devices.allow = c 1:5 rwm
+# consoles
+lxc.cgroup.devices.allow = c 5:1 rwm
+lxc.cgroup.devices.allow = c 5:0 rwm
+# /dev/{,u}random
+lxc.cgroup.devices.allow = c 1:9 rwm
+lxc.cgroup.devices.allow = c 1:8 rwm
+lxc.cgroup.devices.allow = c 136:* rwm
+lxc.cgroup.devices.allow = c 5:2 rwm
+# rtc
+lxc.cgroup.devices.allow = c 254:0 rm
+# fuse
+lxc.cgroup.devices.allow = c 10:229 rwm
+# tun
+lxc.cgroup.devices.allow = c 10:200 rwm
+# full
+lxc.cgroup.devices.allow = c 1:7 rwm
+# hpet
+lxc.cgroup.devices.allow = c 10:228 rwm
+# kvm
+lxc.cgroup.devices.allow = c 10:232 rwm
diff --git a/nova/virt/lxc/driver.py b/nova/virt/lxc/driver.py
new file mode 100644
index 0000000..d683d51
--- /dev/null
+++ b/nova/virt/lxc/driver.py
@@ -0,0 +1,161 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright 2010 United States Government as represented by the
+# Administrator of the National Aeronautics and Space Administration.
+# All Rights Reserved.
+# Copyright (c) 2013 Canonical Ltd
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+"""
+lxc hypervisor drvier
+"""
+
+from oslo.config import cfg
+
+from nova import block_device
+from nova.compute import power_state
+from nova.compute import task_states
+from nova import db
+from nova import exception
+from nova.openstack.common.gettextutils import _
+from nova.openstack.common import log as logging
+from nova.virt import driver
+from nova.virt import virtapi
+from nova.virt.lxc import hostops
+from nova.virt.lxc import vmops
+from nova.virt.lxc import volumeops
+
+lxc_opts = [
+    cfg.StrOpt('lxc_path',
+                default='/var/lib/lxc',
+                help='Default lxc configuration path'),
+    cfg.StrOpt('cgroups_path',
+               default='/sys/fs/cgroup',
+               help='Default cgroups path'),
+    cfg.StrOpt('lxc_config_template',
+              default='$pybasedir/nova/virt/lxc/config.tmpl',
+              help='Template file for lxc configuration file'),
+    cfg.StrOpt('lxc_fstab_template',
+              default='$pybasedir/nova/virt/lxc/fstab.tmpl',
+              help='Template file for lxc fstab file'),
+    ]
+
+CONF = cfg.CONF
+CONF.register_opts(lxc_opts)
+CONF.import_opt('host', 'nova.netconf')
+
+LOG = logging.getLogger(__name__)
+
+class LXCDriver(driver.ComputeDriver):
+    capabilities = {
+        "has_imagecache": False,
+        "supports_recreate": False,
+        }
+
+    """lxc hypervisor driver."""
+
+    def __init__(self, virtapi, read_only=False):
+        super(LXCDriver, self).__init__(virtapi)
+        self.hostops = hostops.HostOps()
+        self.vmops = vmops.VMOps()
+        self.volumeops = volumeops.VolumeOps()
+
+    def init_host(self, host):
+        if not os.path.exists("/usr/bin/lxc-version"):
+            LOG.error(_('LXC is not installed'))
+
+    def list_instances(self):
+        return self.vmops.list_instances()
+
+    def plug_vifs(self, instance, network_info):
+        """Plug VIFs into networks."""
+        pass
+
+    def unplug_vifs(self, instance, network_info):
+        """Unplug VIFs from networks."""
+        pass
+
+    def spawn(self, context, instance, image_meta, injected_files,
+              admin_password, network_info=None, block_device_info=None):
+        self.vmops.spawn(context, instance, image_meta, injected_files,
+            admin_password, network_info, block_device_info)
+
+    def reboot(self, context, instance, network_info, reboot_type,
+               block_device_info=None, bad_volumes_callback=None):
+        pass
+
+    def power_off(self, instance):
+        self.vmops.power_off(instance)
+
+    def power_on(self, context, instance, network_info, block_device_info):
+        self.vmops.power_on(instance)
+
+    def restore(self, instance):
+        pass
+
+    def pause(self, instance):
+        pass
+
+    def unpause(self, instance):
+        pass
+
+    def suspend(self, instance):
+        pass
+
+    def resume(self, instance, network_info, block_device_info=None):
+        pass
+
+    def destroy(self, instance, network_info, block_device_info=None,
+                destroy_disks=True, context=None):
+        self.vmops.destroy(instance, network_info, block_device_info,
+                           destroy_disks, context)
+        self.virtapi.instance_update(context.get_admin_context(),
+            instance['uuid'], {'power_state': power_state.SHUTDOWN})
+
+    def attach_volume(self, context, connection_info, instance, mountpoint,
+                      encryption=None):
+        """Attach the disk to the instance at mountpoint using info."""
+        self.volumeops.attach_volume(context, connection_info, instance, mountpoint,
+                          encryption=None)
+        return True
+
+    def detach_volume(self, connection_info, instance, mountpoint,
+                      encryption=None):
+        """Detach the disk attached to the instance."""
+        self.volumeops.detach_volume(context, connection_info, instance, mountpoint,
+                        encryption=None)
+        return True
+
+    def get_info(self, instance):
+        state = self.vmops.container_exists(instance)
+        if state:
+            pstate = power_state.RUNNING
+        elif state is False:
+            pstate = power_state.SHUTDOWN
+        else:
+            pstate = power_state.NOSTATE
+        return {'state': pstate,
+                'max_mem': 0,
+                'mem': 0,
+                'num_cpu': 2,
+                'cpu_time': 0}
+
+    def get_console_output(self, instance):
+        reteurn self.vmops.get_console_output(instance)
+
+    def get_available_resource(self, nodename):
+        return self.hostops.get_compute_stats()
+
+    def get_host_stats(self, refresh=False):
+        return self.hostops.get_host_stats(refresh)
diff --git a/nova/virt/lxc/fstab.tmpl b/nova/virt/lxc/fstab.tmpl
new file mode 100644
index 0000000..a30d118
--- /dev/null
+++ b/nova/virt/lxc/fstab.tmpl
@@ -0,0 +1,6 @@
+proc            proc         proc    nodev,noexec,nosuid 0 0
+sysfs           sys          sysfs defaults  0 0
+/sys/fs/fuse/connections sys/fs/fuse/connections none bind 0 0
+/sys/kernel/debug sys/kernel/debug none bind 0 0
+/sys/kernel/security sys/kernel/security none bind 0 0
+/sys/fs/pstore sys/fs/pstore none bind 0 0
diff --git a/nova/virt/lxc/hostops.py b/nova/virt/lxc/hostops.py
new file mode 100644
index 0000000..10ba98c
--- /dev/null
+++ b/nova/virt/lxc/hostops.py
@@ -0,0 +1,137 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright 2010 United States Government as represented by the
+# Administrator of the National Aeronautics and Space Administration.
+# All Rights Reserved.
+# Copyright (c) 2013 Canonical Ltd
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import os
+import multiprocessing
+import platform
+import sys
+
+from oslo.config import cfg
+
+from nova.openstack.common import log as logging
+from nova.openstack.common.gettextutils import _
+from nova.openstack.common import jsonutils
+
+
+CONF = cfg.CONF
+
+log = logging.getLogger(__name__)
+
+class HostOps(object):
+    def __init__(self):
+        self._stats = None
+
+    def get_host_stats(self, refresh=False):
+        if refresh or not self._stats:
+            self._update_stats()
+        return self._stats
+
+    def get_compute_stats(self):
+        # Updating host information
+        disk = self. _get_disk_info()
+        memory = self._get_host_memory()
+
+        dic = {'vcpus': 1,
+               'local_gb': disk['total'],
+               'vcpus_used': 0,
+               'memory_mb': memory['total'],
+               'memory_mb_used': memory['total'] - memory['free'],
+               'local_gb_used': disk['total'] - disk['free'],
+               'hypervisor_type': 'lxc',
+               'hypervisor_version': '1.0',
+               'hypervisor_hostname': platform.node(),
+               'cpu_info': '?',
+               'supported_instances': jsonutils.dumps([
+                        ('i686', 'lxc', 'lxc'),
+                        ('x86_64', 'lxc', 'lxc')]),
+        }
+        return dic
+
+    def _update_stats(self):
+        memory = self._get_host_memory()
+        disk = self._get_disk_info()
+        cpu = serlf._get_cpu_info()
+
+        data = {}
+        data["vpcus"] = 1
+        data["cpu_info"] = \
+                {'vendor': cpu['vendor'],
+                 'model': cpu['model'],
+                 'topology': { 'cores': 1,
+                               'socket': multiprocessing.cpu_count(),
+                               'threads': 1,}
+                }
+        data["disk_total"] = disk['total']
+        data["disk_available"] = disk["free"]
+        data["disk_used"] = data["disk_total"] - data["disk_available"]
+        data["memory_mb"] = memory["total"]
+        data["host_memory_total"] = memory["total"]
+        data["host_memory_free"] = memory["free"]
+        data['hypverisor_type'] = 'lxc'
+        data['hypervisor_version'] = '1.0'
+        data['hypervisor_hostname'] = platform.node()
+        data['supported_instances'] = [('i686', 'lxc', 'lxc'),
+                                       ('x86_64', 'lxc', 'lxc')]
+        self._stats = data
+        return data
+
+
+    def _get_host_memory(self):
+        if sys.platform.upper() not in ['LINUX2', 'LINUX3']:
+            return 1
+
+        data = {}
+        for line in open('/proc/meminfo'):
+            if ':' in line:
+                key, value = line.split(":", 1)
+                if key in ["MemTotal", "MemFree", "Buffers", "Cached"]:
+                    data[key] = int(value.split()[0])
+        return{'total':data['MemTotal'], 'free': (data["MemFree"] + data["Buffers"] + data["Cached"])}
+
+
+    def _get_disk_info(self):
+        hddinfo = os.statvfs(CONF.instances_path)
+        total = hddinfo.f_frsize * hddinfo.f_blocks
+        free = hddinfo.f_frsize * hddinfo.f_bavail
+        return {'total': total, 'free': free}
+
+
+    def _get_cpu_info(self):
+        cpuinfo = dict()
+        cpuinfo['features'] = list()
+        if sys.platform.upper() not in ['LINUX2', 'LINUX3']:
+            return 0
+
+        for line in open('/proc/cpuinfo').readlines():
+            line = line.split(':')
+            line[0] = line.strip().replace(' ', '_')
+            if len(line) > 1:
+                line[1] = line[1].strip()
+
+            if line[0] == 'vendor_id':
+                cpuinfo['vendor'] = line[1]
+
+            if line[0] == 'model_name':
+                cpuinfo['model'] = line[1]
+
+            if line[0] == 'flags':
+                cpuinfo['features'] += line[1].split()
+
+        cpuinfo['features'] = list(set(cpuinfo['features']))
+        return cpuinfo
diff --git a/nova/virt/lxc/vmops.py b/nova/virt/lxc/vmops.py
new file mode 100644
index 0000000..f5a5d47
--- /dev/null
+++ b/nova/virt/lxc/vmops.py
@@ -0,0 +1,142 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright 2010 United States Government as represented by the
+# Administrator of the National Aeronautics and Space Administration.
+# All Rights Reserved.
+# Copyright (c) 2013 Canonical Ltd
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import os
+
+import jinja2
+from oslo.config import cfg
+
+from nova.openstack.common import excutils
+from nova.openstack.common import fileutils
+from nova.openstack.common.gettextutils import _
+from nova.openstack.common import log as logging
+from nova import exception
+from nova import utils
+from nova.compute import power_state
+from nova.virt import images
+from nova.virt.disk import api as disk
+from nova.virt.libvirt import utils as libvirt_utils
+from nova.virt.lxc import vmutils
+
+LOG = logging.getLogger(__name__)
+
+CONF = cfg.CONF
+
+MAX_CONSOLE_BYTES = 102400
+
+class VMOps(object):
+    def __init__(self):
+        self.vmutils = vmutils.VMUtils()
+
+    def spawn(self, context, instance, image_meta, injected_files,
+              admin_password, network_info=None, block_device_info=None):
+        LOG.info(_('Spawning instance'), instance=instance)
+        try:
+            if self.vmutils.container_exists(instance):
+                raise exception.InstanceExists(name=instance['uuid'])
+
+            instance_path = os.path.join(CONF.instances_path, instance['uuid'])
+            image_path = os.path.join(instance_path, 'disk')
+            container_rootfs = os.path.join(instance_path, 'rootfs')
+            lxc_container = os.path.join(CONF.lxc_path, instance['uuid'])
+            console_file = os.path.join(instance_path, 'console.log')
+
+            def _lxc_setup_directories():
+                LOG.info(_('Creating initial LXC directories'),
+                         instance=instance)
+                if not os.path.exists(lxc_container):
+                    utils.execute('mkdir', '-p', lxc_container, run_as_root=True)
+
+                if not os.path.exists(container_rootfs):
+                    utils.execute('mkdir', '-p', container_rootfs, run_as_root=True)
+
+                if not os.path.exists(instance_path):
+                    os.mkdir(instance_path)
+
+            _lxc_setup_directories()
+
+            def _lxc_build_config():
+               LOG.info(_('Build LXC configuration file'),
+                          instance=instance)
+               for vif in network_info:
+                   mac_address = vif['address']
+               network_bridge = network_info[0]['network']['bridge']
+
+               tmpl_path, tmpl_file = os.path.split(CONF.lxc_config_template)
+               env = jinja2.Environment(loader=jinja2.FileSystemLoader(tmpl_path))
+               template = env.get_template(tmpl_file)
+               lxc_config = template.render({'container_name': instance['uuid'],
+                                             'container_rootfs': container_rootfs,
+                                             'container_link': network_bridge,
+                                             'container_hwaddr': mac_address,
+                                             'console_file': console_file,
+                                             'container_fstab': '%s/%s/fstab' % (CONF.lxc_path, instance['uuid'])})
+
+               config_file = os.path.join(CONF.lxc_path, instance['uuid'], 'config')
+               vmutils.write_to_file(config_file, lxc_config)
+
+               fstab_file = os.path.join(CONF.lxc_path, instance['uuid'], 'fstab')
+               fstab_config = open(CONF.lxc_fstab_template, 'r').read()
+               vmutils.write_to_file(fstab_file, fstab_config)
+
+            _lxc_build_config()
+
+            def _lxc_ready_container():
+                LOG.info(_('Downloading and Mounting image'), instance=instance)
+                images.fetch(context, instance['image_ref'], image_path,
+                             instance['user_id'], instance['project_id'])
+                disk.setup_container(image_path, container_dir=container_rootfs,
+                                     use_cow=CONF.use_cow_images)
+
+            _lxc_ready_container()
+
+            def _lxc_start_container():
+                LOG.info(_('Starting LXC container'), instance=instance)
+                self.vmutils.start_container(instance)
+
+            _lxc_start_container()
+        except Exception as ex:
+            LOG.exception(ex)
+
+    def destroy(self, instance, network_info, block_device_info=None,
+                destroy_disks=True, context=None):
+        LOG.info(_('Destroying LXC container'), instance=instance)
+        container_dir = os.path.join(CONF.instances_path, instance['uuid'], 'rootfs')
+        instance_dir = os.path.join(CONF.instances_path, instance['uuid'])
+        disk.teardown_container(container_dir=container_dir)
+        self.vmutils.destroy_container(instance)
+
+    def power_off(self, instance):
+        self.vmutils.stop_container(instance)
+
+    def power_on(self, instance):
+        self.vmutils.start_container(instance)
+
+    def get_console_output(self, instance):
+        console_file = os.path.join(CONF.instances_path, instance['uuid'], 'console.log')
+        with libvirt_utils.file_open(console_file, 'r') as fp:
+            log_data, remaining = utils.last_bytes(fp,
+                                                   MAX_CONSOLE_BYTES)
+            return log_data
+
+    def list_instances(self):
+        return self.vmutils.list_containers()
+
+    def container_exists(self, instance):
+        return self.vmutils.container_exists(instance)
diff --git a/nova/virt/lxc/vmutils.py b/nova/virt/lxc/vmutils.py
new file mode 100644
index 0000000..9cd3802
--- /dev/null
+++ b/nova/virt/lxc/vmutils.py
@@ -0,0 +1,58 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright 2010 United States Government as represented by the
+# Administrator of the National Aeronautics and Space Administration.
+# All Rights Reserved.
+# Copyright (c) 2013 Canonical Ltd
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+from nova.openstack.common.gettextutils import _
+from nova.openstack.common import log as logging
+from nova import utils
+
+LOG = logging.getLogger(__name__)
+
+def write_to_file(path, contents):
+    utils.execute('tee', path,
+            process_input=contents, run_as_root=True)
+
+class VMUtils(object):
+    def __init__(self):
+        pass
+
+    def container_exists(self, instance):
+        (state, out) = utils.execute('lxc-info', '--name', instance['uuid'],
+                           '-s', run_as_root=True)
+        state = state.split()[1]
+        if state == 'RUNNING':
+            return True
+        else:
+            return False
+
+    def stop_container(self, instance):
+        utils.execute('lxc-stop', '-n', instance['uuid'], run_as_root=True)
+
+    def start_container(self, instance):
+        utils.execute('lxc-start', '-d', '--name', instance['uuid'], run_as_root=True)
+
+    def destroy_container(self, instance):
+        utils.execute('lxc-destroy', '-f', '-n', instance['uuid'], run_as_root=True)
+
+    def find_container_pid(self, instance):
+        (pid, err) = utils.execute('lxc-info', '-n', instance['uuid'], '-p', run_as_root=True)
+        pid = state.split()[1]
+        return pid
+
+    def list_containers(self):
+        utils.execute('lxc-ls', '-1', run_as_root=True)
diff --git a/nova/virt/lxc/volumeops.py b/nova/virt/lxc/volumeops.py
new file mode 100644
index 0000000..05f4aa4
--- /dev/null
+++ b/nova/virt/lxc/volumeops.py
@@ -0,0 +1,73 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright 2010 United States Government as represented by the
+# Administrator of the National Aeronautics and Space Administration.
+# All Rights Reserved.
+# Copyright (c) 2013 Canonical Ltd
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import os
+
+from oslo.config import cfg
+from nova.openstack.common.gettextutils import _
+from nova.openstack.common import log as logging
+from nova.virt.lxc import vmutils
+
+lxc_volume_opts = [
+    cfg.StrOpt('lxc_volume_group',
+        help='LVM volume Group that is used for attached storage for VM.'),
+]
+
+CONF = cfg.CONF
+CONF.register_opts(lxc_volume_opts)
+LOG = logging.getLogger(__name__)
+
+
+class VolumeOps(object):
+    def __init__(self):
+        self.vmutils = vmutils.VMUtils()
+        self.vg_path = os.path.join('/dev/', CONF.lxc_volume_group)
+
+    def attach_volume(self, context, connection_info, instance,
+                      mountpoint, encryption=None):
+        volume_path = os.path.join(self.vg_path, 'volume-%s'
+                      % connection_info['data']['volume_id'])
+
+        s = os.stat(volume_path)
+        major_num = os.major(s.st_rdev)
+        minor_num = os.minor(s.st_rdev)
+        mode = s.S_IMODE(s.st_mode)
+
+        cgroup_whitelist = os.path.join('/sys/fs/cgroup/devices/lxc', instance['uuid'],
+                            'devices_allow')
+        perm = "b %d:%d rwm" %  (major_num, minor_num)
+        utils.execute('tee'. cgroup_whitelist,
+               process_input=perm, run_as_root=True)
+
+        # Create the target
+        container_pid = self.vmutils.get_container_pid(instance)
+        rootfs = "/proc/%s/root/" % container_pid
+        container_path = "%s/%s"  % (rootfs, mountpoint)
+
+        os.mknod(container_path, s.st_mode, s.st_rdev)
+        os.chmod(container_path, mode)
+
+
+    def detach_volume(self, connection_info, instance, mountpoint,
+                      encryption=None):
+        container_pid = self.vmutils.get_container_pid(instance)
+        rootfs = "/proc/%s/root" % container_pid
+        container_path = "%s/%s" % (rootfs, mountpoint)
+        os.unlink(container_path)
+
